{"version":3,"file":"index.umd.js","sources":["../src/utils.js","../src/component.js","../src/fetch.js","../src/interval.js","../src/truncate.js","../src/index.js"],"sourcesContent":["export const checkForAlpine = () => {\n    if (! window.Alpine) {\n        throw new Error('[Magic Helpers] Alpine is required for the magic helpers to function correctly.')\n    }\n}\n\nexport const saferEval = (expression, dataContext, additionalHelperVariables = {}) => {\n    if (typeof expression === 'function') {\n        return expression.call(dataContext)\n    }\n\n    return (new Function(['$data', ...Object.keys(additionalHelperVariables)], `var __alpine_result; with($data) { __alpine_result = ${expression} }; return __alpine_result`))(\n        dataContext, ...Object.values(additionalHelperVariables)\n    )\n}\n","import { checkForAlpine, saferEval } from './utils'\n\n// TODO: These can be refactored some to combine functionality\nconst AlpineComponentMagicMethod = {\n    start() {\n        checkForAlpine()\n\n        Alpine.addMagicProperty('parent', function ($el) {\n            if (typeof $el.$parent !== 'undefined') return $el.$parent\n\n            const parentComponent = $el.parentNode.closest('[x-data]')\n\n            if (!parentComponent) throw new Error('Parent component not found')\n\n            let data\n\n            if (parentComponent.__x) {\n                data = parentComponent.__x.getUnobservedData()\n            } else {\n                // Component isn't ready yet so lets try to get its initial state\n                data = saferEval(parentComponent.getAttribute('x-data'), parentComponent)\n            }\n\n            $el.$parent = allowTwoWayCommunication(data, parentComponent)\n\n            const parentObserver = new MutationObserver(mutations => {\n                for (let i = 0; i < mutations.length; i++) {\n                    const closestParentComponent = mutations[i].target.closest('[x-data]')\n\n                    if (closestParentComponent && !closestParentComponent.isSameNode(parentComponent)) continue\n\n                    if (!closestParentComponent.__x) {\n                        throw 'Error locating $parent data'\n                    }\n\n                    $el.$parent = allowTwoWayCommunication(closestParentComponent.__x.getUnobservedData(), parentComponent)\n                    $el.__x.updateElements($el)\n                }\n            })\n\n            parentObserver.observe(parentComponent, {\n                attributes: true,\n                childList: true,\n                characterData: true,\n                subtree: true,\n            })\n\n            return data\n        })\n\n        Alpine.addMagicProperty('component', function () {\n            return function (componentName) {\n                if (typeof this[componentName] !== 'undefined') return this[componentName]\n\n                const componentBeingObserved = document.querySelector(`[x-data][x-id=\"${componentName}\"], [x-data]#${componentName}`)\n\n                if (!componentBeingObserved) {\n                    throw 'Component not found'\n                }\n\n                // Set initial state\n                let data\n\n                if (componentBeingObserved.__x) {\n                    data = componentBeingObserved.__x.getUnobservedData()\n                } else {\n                    // Component isn't ready yet so lets try to get its initial state\n                    data = saferEval(componentBeingObserved.getAttribute('x-data'), componentBeingObserved)\n                }\n\n                this[componentName] = allowTwoWayCommunication(data, componentBeingObserved)\n\n                const observer = new MutationObserver(mutations => {\n                    for (let i = 0; i < mutations.length; i++) {\n                        const closestParentComponent = mutations[i].target.closest('[x-data]')\n\n                        if ((closestParentComponent && closestParentComponent.isSameNode(this.$el))) continue\n\n                        if (!closestParentComponent.__x) {\n                            throw 'Error locating $component data'\n                        }\n\n                        this[componentName] = allowTwoWayCommunication(closestParentComponent.__x.getUnobservedData(), componentBeingObserved)\n                    }\n                })\n\n                observer.observe(componentBeingObserved, {\n                    attributes: true,\n                    childList: true,\n                    characterData: true,\n                    subtree: true,\n                })\n\n                return this[componentName]\n            }\n        })\n    }\n}\n\nconst allowTwoWayCommunication = (data, observedComponent) => {\n    return new Proxy(data, {\n        set(target, prop, value) {\n            if (!observedComponent.__x) {\n                throw new Error('Failed to communicate with observed component')\n            }\n\n            observedComponent.__x.$data[prop] = value\n\n            return true\n        }\n    })\n}\n\nconst alpine = window.deferLoadingAlpine || ((alpine) => alpine())\n\nwindow.deferLoadingAlpine = function (callback) {\n    alpine(callback)\n\n    AlpineComponentMagicMethod.start()\n}\n\nexport default AlpineComponentMagicMethod\n","import axios from 'axios'\nimport { checkForAlpine } from './utils'\n\nconst AlpineFetchMagicMethod = {\n    start() {\n        checkForAlpine()\n\n        Alpine.addMagicProperty('fetch', function () {\n            return (...parameters) => {\n                if (typeof parameters[0] === 'string' && parameters[0].length) {\n                    return axios(parameters[0]).then(response => response.hasOwnProperty('data') ?  response.data : response)\n                }\n\n                if (typeof parameters[0] === 'object') {\n                    return axios(parameters[0])\n                }\n\n                return parameters[0]\n            }\n        })\n    }\n}\n\nconst alpine = window.deferLoadingAlpine || ((alpine) => alpine())\n\nwindow.deferLoadingAlpine = function (callback) {\n    AlpineFetchMagicMethod.start()\n\n    alpine(callback)\n}\n\nexport default AlpineFetchMagicMethod\n","import { checkForAlpine } from './utils'\n\nconst AlpineIntervalMagicMethod = {\n    start() {\n        checkForAlpine()\n\n        Alpine.addMagicProperty('interval', function () {\n            return function (...parameters) {\n                if (typeof parameters[0] !== 'function') return parameters[0]\n\n                let timer = parameters[1],\n                    delay = 0,\n                    forceInterval = false\n\n                // Users can pass in an object as a second parameter instead\n                if (typeof parameters[1] === 'object') {\n                    if (parameters[1].hasOwnProperty('timer')) {\n                        timer = parameters[1].timer\n                    }\n\n                    if (parameters[1].hasOwnProperty('delay')) {\n                        delay = parameters[1].delay\n                    }\n\n                    if (parameters[1].hasOwnProperty('forceInterval')) {\n                        forceInterval = parameters[1].forceInterval\n                    }\n                }\n\n                let loop = () => {\n                    const test = this.hasOwnProperty('autoIntervalTest') ? this.autoIntervalTest : true\n\n                    setTimeout(() => {\n                        if (!this.autoIntervalLoop) return\n                        test && parameters[0].call(this)\n                        forceInterval ? this.autoIntervalLoop() : requestAnimationFrame(this.autoIntervalLoop)\n                    }, timer)\n                }\n\n                this.autoIntervalLoop = loop\n\n                setTimeout(() => {\n                    if (!this.autoIntervalLoop) return\n\n                    forceInterval ? this.autoIntervalLoop() : requestAnimationFrame(this.autoIntervalLoop)\n                }, delay)\n\n                this.$watch('autoIntervalTest', test => {\n                    if (test) {\n                        this.autoIntervalLoop = loop\n\n                        forceInterval ? this.autoIntervalLoop() : requestAnimationFrame(this.autoIntervalLoop)\n                    } else {\n                        clearTimeout(this.autoIntervalLoop)\n\n                        this.autoIntervalLoop = null\n                    }\n                })\n            }\n        })\n    }\n}\n\nconst alpine = window.deferLoadingAlpine || ((alpine) => alpine())\n\nwindow.deferLoadingAlpine = function (callback) {\n    AlpineIntervalMagicMethod.start()\n\n    alpine(callback)\n}\n\nexport default AlpineIntervalMagicMethod\n","import { checkForAlpine } from './utils'\n\nconst AlpineTruncateMagicMethod = {\n    start() {\n        checkForAlpine()\n\n        Alpine.addMagicProperty('truncate', function () {\n            return (...parameters) => {\n                if (typeof parameters[0] !== 'string') return parameters[0]\n                let ellipsis = '…'\n\n                // If the second parameter isn't truthy, return the full string\n                if (!parameters[1]) return parameters[0]\n\n                // if only a number or string is passed in, keep it simple\n                if (typeof parameters[1] !== 'object') {\n                    if (typeof parameters[2] !== 'undefined') {\n                        ellipsis = parameters[2]\n                    }\n                    return parameters[0].slice(0, parameters[1]) + ellipsis\n                }\n\n                // Customize the …\n                if (parameters[1].hasOwnProperty('ellipsis')) {\n                    ellipsis = parameters[1].ellipsis\n                }\n\n                // If words or characters is set, also check that they are truthy. Setting to 0, for example, shoudld show all\n                if (parameters[1].hasOwnProperty('words') && parameters[1].words) {\n                    return parameters[0].split(\" \").splice(0, parameters[1].words).join(\" \") + ellipsis\n                }\n                if (parameters[1].hasOwnProperty('characters') && parameters[1].characters) {\n                    return parameters[0].slice(0, parameters[1]['characters']) + ellipsis\n                }\n                return parameters[0]\n            }\n        })\n    }\n}\n\nconst alpine = window.deferLoadingAlpine || ((alpine) => alpine())\n\nwindow.deferLoadingAlpine = function (callback) {\n    AlpineTruncateMagicMethod.start()\n\n    alpine(callback)\n}\n\nexport default AlpineTruncateMagicMethod\n","import AlpineComponentMagicMethod from './component'\nimport AlpineFetchMagicMethod from './fetch'\nimport AlpineIntervalMagicMethod from './interval'\nimport AlpineTruncateMagicMethod from './truncate'\n\nconst alpine = window.deferLoadingAlpine || ((alpine) => alpine())\n\nwindow.deferLoadingAlpine = function (callback) {\n    AlpineComponentMagicMethod.start()\n    AlpineFetchMagicMethod.start()\n    AlpineIntervalMagicMethod.start()\n    AlpineTruncateMagicMethod.start()\n\n    alpine(callback)\n}\n\nexport default {\n    AlpineComponentMagicMethod,\n    AlpineFetchMagicMethod,\n    AlpineIntervalMagicMethod,\n    AlpineTruncateMagicMethod\n}\n"],"names":["checkForAlpine","window","Alpine","Error","saferEval","expression","dataContext","additionalHelperVariables","call","Function","Object","keys","values","AlpineComponentMagicMethod","start","addMagicProperty","$el","$parent","data","parentComponent","parentNode","closest","__x","getUnobservedData","getAttribute","allowTwoWayCommunication","MutationObserver","mutations","i","length","closestParentComponent","target","isSameNode","updateElements","observe","attributes","childList","characterData","subtree","componentName","componentBeingObserved","document","querySelector","this","_this","observedComponent","Proxy","set","prop","value","$data","alpine","deferLoadingAlpine","callback","AlpineFetchMagicMethod","parameters","axios","then","response","hasOwnProperty","AlpineIntervalMagicMethod","timer","delay","forceInterval","loop","test","autoIntervalTest","setTimeout","autoIntervalLoop","requestAnimationFrame","$watch","clearTimeout","AlpineTruncateMagicMethod","ellipsis","slice","words","split","splice","join","characters"],"mappings":"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"}